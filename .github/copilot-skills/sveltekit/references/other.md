# Sveltekit - Other

**Pages**: 30

---

## Adapters

**URL**: https://kit.svelte.dev/docs/adapters

**Contents**:
  - Getting started
  - Core concepts
  - Build and deploy
  - Advanced
  - Best practices
  - Appendix
  - Reference
- Adapters

Before you can deploy your SvelteKit app, you need to adapt it for your deployment target. Adapters are small plugins that take the built app as input and generate output for deployment.

Official adapters exist for a variety of platforms — these are documented on the following pages:

Additional community-provided adapters exist for other platforms.

Your adapter is specified in svelte.config.js:

Your adapter is run when executing vite build. It determines how the output is converted for different platforms.

Some adapters may have access to additional information about the request. For example, Cloudflare Workers can access an env object containing KV namespaces etc. This can be passed to the RequestEvent used in hooks and server routes as the platform property — consult each adapter’s documentation to learn more.

Edit this page on GitHub llms.txt

**Examples**:

```python
import const adapter: (opts: any) => import("@sveltejs/kit").Adapteradapter from 'svelte-adapter-foo';

/** @type {import('@sveltejs/kit').Config} */
const const config: Config@type{import('@sveltejs/kit').Config}config = {
	Config.kit?: KitConfig | undefinedSvelteKit options.
@seehttps://svelte.dev/docs/kit/configurationkit: {
		KitConfig.adapter?: Adapter | undefinedYour adapter is run when executing vite build. It determines how the output is converted for different platforms.
@defaultundefin
...
```

```javascript
const adapter: (opts: any) => import("@sveltejs/kit").Adapter
```

```javascript
const config: Config
```

---

## Cloudflare

**URL**: https://kit.svelte.dev/docs/adapter-cloudflare

**Contents**:
  - Getting started
  - Core concepts
  - Build and deploy
  - Advanced
  - Best practices
  - Appendix
  - Reference
- Cloudflare

To deploy to Cloudflare Workers or Cloudflare Pages, use adapter-cloudflare.

This adapter will be installed by default when you use adapter-auto. If you plan on staying with Cloudflare, you can switch from adapter-auto to using this adapter directly so that event.platform is emulated during local development, type declarations are automatically applied, and the ability to set Cloudflare-specific options is provided.

Install with npm i -D @sveltejs/adapter-cloudflare, then add the adapter to your svelte.config.js:

Path to your Wrangler configuration file. If you would like to use a Wrangler configuration filename other than wrangler.jsonc, wrangler.json, or wrangler.toml you can specify it using this option.

Preferences for the emulated platform.env local bindings. See the getPlatformProxy Wrangler API documentation for a full list of options.

Whether to render a plaintext 404.html page or a rendered SPA fallback page for non-matching asset requests.

For Cloudflare Workers, the default behaviour is to return a null-body 404-status response for non-matching assets requests. However, if the assets.not_found_handling Wrangler configuration setting is set to "404-page", this page will be served if a request fails to match an asset. If assets.not_found_handling is set to "single-page-application", the adapter will render a SPA fallback index.html page regardless of the fallback option specified.

For Cloudflare Pages, this page will only be served when a request that matches an entry in routes.exclude fails to match an asset.

Most of the time plaintext is sufficient, but if you are using routes.exclude to manually exclude a set of prerendered pages without exceeding the 100 route limit, you may wish to use spa instead to avoid showing an unstyled 404 page to users.

See Cloudflare Pages’ Not Found behaviour for more info.

Only for Cloudflare Pages. Allows you to customise the _routes.json file generated by adapter-cloudflare.

You can have up to 100 include and ex

*[Content truncated - see full docs]*

**Examples**:

```python
import import adapteradapter from '@sveltejs/adapter-cloudflare';

/** @type {import('@sveltejs/kit').Config} */
const const config: {
    kit: {
        adapter: any;
    };
}@type{import('@sveltejs/kit').Config}config = {
	kit: {
    adapter: any;
}kit: {
		adapter: anyadapter: import adapteradapter({
			// See below for an explanation of these options
			config: undefinedconfig: var undefinedundefined,
			platformProxy: {
    configPath: undefined;
    environment: undefined;
    persist: und
...
```

```text
import adapter
```

```javascript
const config: {
    kit: {
        adapter: any;
    };
}
```

---

## Configuration

**URL**: https://kit.svelte.dev/docs/configuration

**Contents**:
  - Getting started
  - Core concepts
  - Build and deploy
  - Advanced
  - Best practices
  - Appendix
  - Reference
- Configuration

Your project’s configuration lives in a svelte.config.js file at the root of your project. As well as SvelteKit, this config object is used by other tooling that integrates with Svelte such as editor extensions.

Your adapter is run when executing vite build. It determines how the output is converted for different platforms.

An extension of vite-plugin-svelte’s options.

Any additional options required by tooling that integrates with Svelte.

The kit property configures SvelteKit, and can have the following properties:

Your adapter is run when executing vite build. It determines how the output is converted for different platforms.

An object containing zero or more aliases used to replace values in import statements. These aliases are automatically passed to Vite and TypeScript.

The built-in $lib alias is controlled by config.kit.files.lib as it is used for packaging.

You will need to run npm run dev to have SvelteKit automatically generate the required alias configuration in jsconfig.json or tsconfig.json.

The directory where SvelteKit keeps its stuff, including static assets (such as JS and CSS) and internally-used routes.

If paths.assets is specified, there will be two app directories — ${paths.assets}/${appDir} and ${paths.base}/${appDir}.

Content Security Policy configuration. CSP helps to protect your users against cross-site scripting (XSS) attacks, by limiting the places resources can be loaded from. For example, a configuration like this...

...would prevent scripts loading from external sites. SvelteKit will augment the specified directives with nonces or hashes (depending on mode) for any inline styles and scripts it generates.

To add a nonce for scripts and links manually included in src/app.html, you may use the placeholder %sveltekit.nonce% (for example <script nonce="%sveltekit.nonce%">).

When pages are prerendered, the CSP header is added via a <meta http-equiv> tag (note that in this case, frame-ancestors, report-uri and sandbox directives 

*[Content truncated - see full docs]*

**Examples**:

```python
import const adapter: () => import("@sveltejs/kit").Adapteradapter from '@sveltejs/adapter-auto';

/** @type {import('@sveltejs/kit').Config} */
const const config: Config@type{import('@sveltejs/kit').Config}config = {
	Config.kit?: KitConfig | undefinedSvelteKit options.
@seehttps://svelte.dev/docs/kit/configurationkit: {
		KitConfig.adapter?: Adapter | undefinedYour adapter is run when executing vite build. It determines how the output is converted for different platforms.
@defaultundefinedada
...
```

```javascript
const adapter: () => import("@sveltejs/kit").Adapter
```

```javascript
const config: Config
```

---

## Errors

**URL**: https://kit.svelte.dev/docs/errors

**Contents**:
  - Getting started
  - Core concepts
  - Build and deploy
  - Advanced
  - Best practices
  - Appendix
  - Reference
- Errors

Errors are an inevitable fact of software development. SvelteKit handles errors differently depending on where they occur, what kind of errors they are, and the nature of the incoming request.

SvelteKit distinguishes between expected and unexpected errors, both of which are represented as simple { message: string } objects by default.

You can add additional properties, like a code or a tracking id, as shown in the examples below. (When using TypeScript this requires you to redefine the Error type as described in type safety).

An expected error is one created with the error helper imported from @sveltejs/kit:

Throws an error with a HTTP status code and an optional message. When called during request handling, this will cause SvelteKit to return an error response without invoking handleError. Make sure you’re not catching the thrown error, which would prevent SvelteKit from handling it.

The parameters of the current route - e.g. for a route like /blog/[slug], a { slug: string } object.

The parameters of the current route - e.g. for a route like /blog/[slug], a { slug: string } object.

Throws an error with a HTTP status code and an optional message. When called during request handling, this will cause SvelteKit to return an error response without invoking handleError. Make sure you’re not catching the thrown error, which would prevent SvelteKit from handling it.

Throws an error with a HTTP status code and an optional message. When called during request handling, this will cause SvelteKit to return an error response without invoking handleError. Make sure you’re not catching the thrown error, which would prevent SvelteKit from handling it.

The parameters of the current route - e.g. for a route like /blog/[slug], a { slug: string } object.

The parameters of the current route - e.g. for a route like /blog/[slug], a { slug: string } object.

Throws an error with a HTTP status code and an optional message. When called during request handling, this will cause Svelt

*[Content truncated - see full docs]*

**Examples**:

```python
import { function error(status: number, body: App.Error): never (+1 overload)Throws an error with a HTTP status code and an optional message.
When called during request handling, this will cause SvelteKit to
return an error response without invoking handleError.
Make sure you’re not catching the thrown error, which would prevent SvelteKit from handling it.
@paramstatus The HTTP status code. Must be in the range 400-599.@parambody An object that conforms to the App.Error type. If a string is pass
...
```

```javascript
function error(status: number, body: App.Error): never (+1 overload)
```

```text
handleError
```

---

## Form actions

**URL**: https://kit.svelte.dev/docs/form-actions

**Contents**:
  - Getting started
  - Core concepts
  - Build and deploy
  - Advanced
  - Best practices
  - Appendix
  - Reference
- Form actions

A +page.server.js file can export actions, which allow you to POST data to the server using the <form> element.

When using <form>, client-side JavaScript is optional, but you can easily progressively enhance your form interactions with JavaScript to provide the best user experience.

In the simplest case, a page declares a default action:

To invoke this action from the /login page, just add a <form> — no JavaScript needed:

If someone were to click the button, the browser would send the form data via POST request to the server, running the default action.

Actions always use POST requests, since GET requests should never have side-effects.

We can also invoke the action from other pages (for example if there’s a login widget in the nav in the root layout) by adding the action attribute, pointing to the page:

Instead of one default action, a page can have as many named actions as it needs:

To invoke a named action, add a query parameter with the name prefixed by a / character:

As well as the action attribute, we can use the formaction attribute on a button to POST the same form data to a different action than the parent <form>:

We can’t have default actions next to named actions, because if you POST to a named action without a redirect, the query parameter is persisted in the URL, which means the next default POST would go through the named action from before.

Each action receives a RequestEvent object, allowing you to read the data with request.formData(). After processing the request (for example, logging the user in by setting a cookie), the action can respond with data that will be available through the form property on the corresponding page and through page.form app-wide until the next update.

Get or set cookies related to the current request

Get or set cookies related to the current request

Gets a cookie that was previously set with cookies.set, or from the request headers.

Get or set cookies related to the current request

The original request obje

*[Content truncated - see full docs]*

**Examples**:

```javascript
/** @satisfies {import('./$types').Actions} */
export const const actions: {
    default: (event: any) => Promise<void>;
}@satisfies{import('./$types').Actions}actions = {
	default: (event: any) => Promise<void>default: async (event: anyevent) => {
		// TODO log the user in
	}
};
```

```javascript
const actions: {
    default: (event: any) => Promise<void>;
}
```

```javascript
const actions: {
    default: (event: any) => Promise<void>;
}
```

---

## Hooks

**URL**: https://kit.svelte.dev/docs/hooks

**Contents**:
  - Getting started
  - Core concepts
  - Build and deploy
  - Advanced
  - Best practices
  - Appendix
  - Reference
- Hooks

‘Hooks’ are app-wide functions you declare that SvelteKit will call in response to specific events, giving you fine-grained control over the framework’s behaviour.

There are three hooks files, all optional:

Code in these modules will run when the application starts up, making them useful for initializing database clients and so on.

You can configure the location of these files with config.kit.files.hooks.

The following hooks can be added to src/hooks.server.js:

This function runs every time the SvelteKit server receives a request — whether that happens while the app is running, or during prerendering — and determines the response. It receives an event object representing the request and a function called resolve, which renders the route and generates a Response. This allows you to modify response headers or bodies, or bypass SvelteKit entirely (for implementing routes programmatically, for example).

This Fetch API interface represents the response to a request.

The handle hook runs every time the SvelteKit server receives a request and determines the response. It receives an event object representing the request and a function called resolve, which renders the route and generates a Response. This allows you to modify response headers or bodies, or bypass SvelteKit entirely (for implementing routes programmatically, for example).

The handle hook runs every time the SvelteKit server receives a request and determines the response. It receives an event object representing the request and a function called resolve, which renders the route and generates a Response. This allows you to modify response headers or bodies, or bypass SvelteKit entirely (for implementing routes programmatically, for example).

Returns true if the sequence of elements of searchString converted to a String is the same as the corresponding elements of this object (converted to a String) starting at position. Otherwise returns false.

This Fetch API interface represents the response to a req

*[Content truncated - see full docs]*

**Examples**:

```javascript
/** @type {import('@sveltejs/kit').Handle} */
export async function function handle({ event, resolve }: {
    event: any;
    resolve: any;
}): Promise<any>@type{import('@sveltejs/kit').Handle}handle({ event: anyevent, resolve: anyresolve }) {
	if (event: anyevent.url.pathname.startsWith('/custom')) {
		return new var Response: new (body?: BodyInit | null, init?: ResponseInit) => ResponseThis Fetch API interface represents the response to a request.
MDN Reference
Response('custom response');
	}

...
```

```javascript
function handle({ event, resolve }: {
    event: any;
    resolve: any;
}): Promise<any>
```

```javascript
function handle({ event, resolve }: {
    event: any;
    resolve: any;
}): Promise<any>
```

---

## Images

**URL**: https://kit.svelte.dev/docs/images

**Contents**:
  - Getting started
  - Core concepts
  - Build and deploy
  - Advanced
  - Best practices
  - Appendix
  - Reference
- Images

Images can have a big impact on your app’s performance. For best results, you should optimize them by doing the following:

Doing this manually is tedious. There are a variety of techniques you can use, depending on your needs and preferences.

Vite will automatically process imported assets for improved performance. This includes assets referenced via the CSS url() function. Hashes will be added to the filenames so that they can be cached, and assets smaller than assetsInlineLimit will be inlined. Vite’s asset handling is most often used for images, but is also useful for video, audio, etc.

@sveltejs/enhanced-img is a plugin offered on top of Vite’s built-in asset handling. It provides plug and play image processing that serves smaller file formats like avif or webp, automatically sets the intrinsic width and height of the image to avoid layout shift, creates images of multiple sizes for various devices, and strips EXIF data for privacy. It will work in any Vite-based project including, but not limited to, SvelteKit projects.

As a build plugin, @sveltejs/enhanced-img can only optimize files located on your machine during the build process. If you have an image located elsewhere (such as a path served from your database, CMS, or backend), please read about loading images dynamically from a CDN.

Adjust vite.config.js:

Returns the SvelteKit Vite plugins.

Type helper to make it easier to use vite.config.ts accepts a direct {@link UserConfig } object, or a function that returns it. The function receives a {@link ConfigEnv } object.

Type helper to make it easier to use vite.config.ts accepts a direct {@link UserConfig } object, or a function that returns it. The function receives a {@link ConfigEnv } object.

Array of vite plugins to use.

Returns the SvelteKit Vite plugins.

Building will take longer on the first build due to the computational expense of transforming images. However, the build output will be cached in ./node_modules/.cache/imagetools so that subse

*[Content truncated - see full docs]*

**Examples**:

```python
<script>
	import logo from '$lib/assets/logo.png';
</script>

<img alt="The project logo" src={logo} />
```

```text
npm i -D @sveltejs/enhanced-img
```

```python
import { function sveltekit(): Promise<Plugin$1<any>[]>Returns the SvelteKit Vite plugins.
sveltekit } from '@sveltejs/kit/vite';
import { function enhancedImages(): Promise<Plugin$1[]>enhancedImages } from '@sveltejs/enhanced-img';
import { function defineConfig(config: UserConfig): UserConfig (+5 overloads)Type helper to make it easier to use vite.config.ts
accepts a direct 
{@link 
UserConfig
}
 object, or a function that returns it.
The function receives a 
{@link 
ConfigEnv
}
 object.
defin
...
```

---

## Netlify

**URL**: https://kit.svelte.dev/docs/adapter-netlify

**Contents**:
  - Getting started
  - Core concepts
  - Build and deploy
  - Advanced
  - Best practices
  - Appendix
  - Reference
- Netlify

To deploy to Netlify, use adapter-netlify.

This adapter will be installed by default when you use adapter-auto, but adding it to your project allows you to specify Netlify-specific options.

Install with npm i -D @sveltejs/adapter-netlify, then add the adapter to your svelte.config.js:

Then, make sure you have a netlify.toml file in the project root. This will determine where to write static assets based on the build.publish settings, as per this sample configuration:

If the netlify.toml file or the build.publish value is missing, a default value of "build" will be used. Note that if you have set the publish directory in the Netlify UI to something else then you will need to set it in netlify.toml too, or use the default value of "build".

New projects will use the current Node LTS version by default. However, if you’re upgrading a project you created a while ago it may be stuck on an older version. See the Netlify docs for details on manually specifying a current Node version.

SvelteKit supports Netlify Edge Functions. If you pass the option edge: true to the adapter function, server-side rendering will happen in a Deno-based edge function that’s deployed close to the site visitor. If set to false (the default), the site will deploy to Node-based Netlify Functions.

You may build your app using functionality provided directly by SvelteKit without relying on any Netlify functionality. Using the SvelteKit versions of these features will allow them to be used in dev mode, tested with integration tests, and to work with other adapters should you ever decide to switch away from Netlify. However, in some scenarios you may find it beneficial to use the Netlify versions of these features. One example would be if you’re migrating an app that’s already hosted on Netlify to SvelteKit.

The _headers and _redirects files specific to Netlify can be used for static asset responses (like images) by putting them into the project root folder.

During compilation, redirect rules 

*[Content truncated - see full docs]*

**Examples**:

```python
import import adapteradapter from '@sveltejs/adapter-netlify';

/** @type {import('@sveltejs/kit').Config} */
const const config: {
    kit: {
        adapter: any;
    };
}@type{import('@sveltejs/kit').Config}config = {
	kit: {
    adapter: any;
}kit: {
		// default options are shown
		adapter: anyadapter: import adapteradapter({
			// if true, will create a Netlify Edge Function rather
			// than using standard Node-based functions
			edge: booleanedge: false,

			// if true, will split your a
...
```

```text
import adapter
```

```javascript
const config: {
    kit: {
        adapter: any;
    };
}
```

---

## Node servers

**URL**: https://kit.svelte.dev/docs/adapter-node

**Contents**:
  - Getting started
  - Core concepts
  - Build and deploy
  - Advanced
  - Best practices
  - Appendix
  - Reference
- Node servers

To generate a standalone Node server, use adapter-node.

Install with npm i -D @sveltejs/adapter-node, then add the adapter to your svelte.config.js:

First, build your app with npm run build. This will create the production server in the output directory specified in the adapter options, defaulting to build.

You will need the output directory, the project’s package.json, and the production dependencies in node_modules to run the application. Production dependencies can be generated by copying the package.json and package-lock.json and then running npm ci --omit dev (you can skip this step if your app doesn’t have any dependencies). You can then start your app with this command:

Development dependencies will be bundled into your app using Rollup. To control whether a given package is bundled or externalised, place it in devDependencies or dependencies respectively in your package.json.

You will typically want to compress responses coming from the server. If you’re already deploying your server behind a reverse proxy for SSL or load balancing, it typically results in better performance to also handle compression at that layer since Node.js is single-threaded.

However, if you’re building a custom server and do want to add a compression middleware there, note that we would recommend using @polka/compression since SvelteKit streams responses and the more popular compression package does not support streaming and may cause errors when used.

In dev and preview, SvelteKit will read environment variables from your .env file (or .env.local, or .env.[mode], as determined by Vite.)

In production, .env files are not automatically loaded. To do so, install dotenv in your project...

...and invoke it before running the built app:

If you use Node.js v20.6+, you can use the --env-file flag instead:

By default, the server will accept connections on 0.0.0.0 using port 3000. These can be customised with the PORT and HOST environment variables:

Alternatively, the server can be

*[Content truncated - see full docs]*

**Examples**:

```python
import import adapteradapter from '@sveltejs/adapter-node';

/** @type {import('@sveltejs/kit').Config} */
const const config: {
    kit: {
        adapter: any;
    };
}@type{import('@sveltejs/kit').Config}config = {
	kit: {
    adapter: any;
}kit: {
		adapter: anyadapter: import adapteradapter()
	}
};

export default const config: {
    kit: {
        adapter: any;
    };
}@type{import('@sveltejs/kit').Config}config;
```

```text
import adapter
```

```javascript
const config: {
    kit: {
        adapter: any;
    };
}
```

---

## Observability

**URL**: https://kit.svelte.dev/docs/observability

**Contents**:
  - Getting started
  - Core concepts
  - Build and deploy
  - Advanced
  - Best practices
  - Appendix
  - Reference
- Observability

Sometimes, you may need to observe how your application is behaving in order to improve performance or find the root cause of a pesky bug. To help with this, SvelteKit can emit server-side OpenTelemetry spans for the following:

Just telling SvelteKit to emit spans won’t get you far, though — you need to actually collect them somewhere to be able to view them. SvelteKit provides src/instrumentation.server.ts as a place to write your tracing setup and instrumentation code. It’s guaranteed to be run prior to your application code being imported, providing your deployment platform supports it and your adapter is aware of it.

Both of these features are currently experimental, meaning they are likely to contain bugs and are subject to change without notice. You must opt in by adding the kit.experimental.tracing.server and kit.experimental.instrumentation.server option in your svelte.config.js:

Tracing — and more significantly, observability instrumentation — can have a nontrivial overhead. Before you go all-in on tracing, consider whether or not you really need it, or if it might be more appropriate to turn it on in development and preview environments only.

SvelteKit provides access to the root span and the current span on the request event. The root span is the one associated with your root handle function, and the current span could be associated with handle, load, a form action, or a remote function, depending on the context. You can annotate these spans with any attributes you wish to record:

Returns the current RequestEvent. Can be used inside server hooks, server load functions, actions, and endpoints (and functions called by them).

In environments without AsyncLocalStorage, this must be called synchronously (i.e. not after an await).

Returns the current RequestEvent. Can be used inside server hooks, server load functions, actions, and endpoints (and functions called by them).

In environments without AsyncLocalStorage, this must be called synchronously (i.e

*[Content truncated - see full docs]*

**Examples**:

```javascript
/** @type {import('@sveltejs/kit').Config} */
const const config: {
    kit: {
        experimental: {
 tracing: {
   server: boolean;
 };
 instrumentation: {
   server: boolean;
 };
        };
    };
}@type{import('@sveltejs/kit').Config}config = {
	kit: {
    experimental: {
        tracing: {
 server: boolean;
        };
        instrumentation: {
 server: boolean;
        };
    };
}kit: {
		experimental: {
    tracing: {
        server: boolean;
    };
    instrumentation: {
        server:
...
```

```javascript
const config: {
    kit: {
        experimental: {
 tracing: {
   server: boolean;
 };
 instrumentation: {
   server: boolean;
 };
        };
    };
}
```

```javascript
const config: {
    kit: {
        experimental: {
 tracing: {
   server: boolean;
 };
 instrumentation: {
   server: boolean;
 };
        };
    };
}
```

---

## Packaging

**URL**: https://kit.svelte.dev/docs/packaging

**Contents**:
  - Getting started
  - Core concepts
  - Build and deploy
  - Advanced
  - Best practices
  - Appendix
  - Reference
- Packaging

You can use SvelteKit to build apps as well as component libraries, using the @sveltejs/package package (npx sv create has an option to set this up for you).

When you’re creating an app, the contents of src/routes is the public-facing stuff; src/lib contains your app’s internal library.

A component library has the exact same structure as a SvelteKit app, except that src/lib is the public-facing bit, and your root package.json is used to publish the package. src/routes might be a documentation or demo site that accompanies the library, or it might just be a sandbox you use during development.

Running the svelte-package command from @sveltejs/package will take the contents of src/lib and generate a dist directory (which can be configured) containing the following:

@sveltejs/package version 1 generated a package.json. This is no longer the case and it will now use the package.json from your project and validate that it is correct instead. If you’re still on version 1, see this PR for migration instructions.

Since you’re now building a library for public use, the contents of your package.json will become more important. Through it, you configure the entry points of your package, which files are published to npm, and which dependencies your library has. Let’s go through the most important fields one by one.

This is the name of your package. It will be available for others to install using that name, and visible on https://npmjs.com/package/<name>.

Read more about it here.

Every package should have a license field so people know how they are allowed to use it. A very popular license which is also very permissive in terms of distribution and reuse without warranty is MIT.

Read more about it here. Note that you should also include a LICENSE file in your package.

This tells npm which files it will pack up and upload to npm. It should contain your output folder (dist by default). Your package.json and README and LICENSE will always be included, so you don’t need to 

*[Content truncated - see full docs]*

**Examples**:

```text
{
	"name": "your-library"
}
```

```text
{
	"license": "MIT"
}
```

```text
{
	"files": ["dist"]
}
```

---

## Page options

**URL**: https://kit.svelte.dev/docs/page-options

**Contents**:
  - Getting started
  - Core concepts
  - Build and deploy
  - Advanced
  - Best practices
  - Appendix
  - Reference
- Page options

By default, SvelteKit will render (or prerender) any component first on the server and send it to the client as HTML. It will then render the component again in the browser to make it interactive in a process called hydration. For this reason, you need to ensure that components can run in both places. SvelteKit will then initialize a router that takes over subsequent navigations.

You can control each of these on a page-by-page basis by exporting options from +page.js or +page.server.js, or for groups of pages using a shared +layout.js or +layout.server.js. To define an option for the whole app, export it from the root layout. Child layouts and pages override values set in parent layouts, so — for example — you can enable prerendering for your entire app then disable it for pages that need to be dynamically rendered.

You can mix and match these options in different areas of your app. For example, you could prerender your marketing page for maximum speed, server-render your dynamic pages for SEO and accessibility and turn your admin section into an SPA by rendering it on the client only. This makes SvelteKit very versatile.

It’s likely that at least some routes of your app can be represented as a simple HTML file generated at build time. These routes can be prerendered.

Alternatively, you can set export const prerender = true in your root +layout.js or +layout.server.js and prerender everything except pages that are explicitly marked as not prerenderable:

Routes with prerender = true will be excluded from manifests used for dynamic SSR, making your server (or serverless/edge functions) smaller. In some cases you might want to prerender a route but also include it in the manifest (for example, with a route like /blog/[slug] where you want to prerender your most recent/popular content but server-render the long tail) — for these cases, there’s a third option, ‘auto’:

If your entire app is suitable for prerendering, you can use adapter-static, which will output fil

*[Content truncated - see full docs]*

**Examples**:

```javascript
export const const prerender: trueprerender = true;
```

```javascript
const prerender: true
```

```javascript
export const const prerender: falseprerender = false;
```

---

## Project structure

**URL**: https://kit.svelte.dev/docs/project-structure

**Contents**:
  - Getting started
  - Core concepts
  - Build and deploy
  - Advanced
  - Best practices
  - Appendix
  - Reference
- Project structure

A typical SvelteKit project looks like this:

You’ll also find common files like .gitignore and .npmrc (and .prettierrc and eslint.config.js and so on, if you chose those options when running npx sv create).

The src directory contains the meat of your project. Everything except src/routes and src/app.html is optional.

(Whether the project contains .js or .ts files depends on whether you opt to use TypeScript when you create your project.)

If you added Vitest when you set up your project, your unit tests will live in the src directory with a .test.js extension.

Any static assets that should be served as-is, like robots.txt or favicon.png, go in here.

If you added Playwright for browser testing when you set up your project, the tests will live in this directory.

Your package.json file must include @sveltejs/kit, svelte and vite as devDependencies.

When you create a project with npx sv create, you’ll also notice that package.json includes "type": "module". This means that .js files are interpreted as native JavaScript modules with import and export keywords. Legacy CommonJS files need a .cjs file extension.

This file contains your Svelte and SvelteKit configuration.

This file (or jsconfig.json, if you prefer type-checked .js files over .ts files) configures TypeScript, if you added typechecking during npx sv create. Since SvelteKit relies on certain configuration being set a specific way, it generates its own .svelte-kit/tsconfig.json file which your own config extends. To make changes to top-level options such as include and exclude, we recommend extending the generated config; see the typescript.config setting for more details.

A SvelteKit project is really just a Vite project that uses the @sveltejs/kit/vite plugin, along with any other Vite configuration.

As you develop and build your project, SvelteKit will generate files in a .svelte-kit directory (configurable as outDir). You can ignore its contents, and delete them at any time (they will be regenerat

*[Content truncated - see full docs]*

**Examples**:

```text
my-project/
├ src/
│ ├ lib/
│ │ ├ server/
│ │ │ └ [your server-only lib files]
│ │ └ [your lib files]
│ ├ params/
│ │ └ [your param matchers]
│ ├ routes/
│ │ └ [your routes]
│ ├ app.html
│ ├ error.html
│ ├ hooks.client.js
│ ├ hooks.server.js
| ├ service-worker.js
│ └ tracing.server.js
├ static/
│ └ [your static assets]
├ tests/
│ └ [your tests]
├ package.json
├ svelte.config.js
├ tsconfig.json
└ vite.config.js
```

---

## Project types

**URL**: https://kit.svelte.dev/docs/project-types

**Contents**:
  - Getting started
  - Core concepts
  - Build and deploy
  - Advanced
  - Best practices
  - Appendix
  - Reference
- Project types

SvelteKit offers configurable rendering, which allows you to build and deploy your project in several different ways. You can build all of the below types of applications and more with SvelteKit. Rendering settings are not mutually exclusive and you may choose the optimal manner with which to render different parts of your application.

If you don’t have a particular way you’d like to build your application in mind, don’t worry! The way your application is built, deployed, and rendered is controlled by which adapter you’ve chosen and a small amount of configuration and these can always be changed later. The project structure and routing will be the same regardless of the project type that you choose.

By default, when a user visits a site, SvelteKit will render the first page with server-side rendering (SSR) and subsequent pages with client-side rendering (CSR). Using SSR for the initial render improves SEO and perceived performance of the initial page load. Client-side rendering then takes over and updates the page without having to rerender common components, which is typically faster and eliminates a flash when navigating between pages. Apps built with this hybrid rendering approach have also been called transitional apps.

You can use SvelteKit as a static site generator (SSG) that fully prerenders your site with static rendering using adapter-static. You may also use the prerender option to prerender only some pages and then choose a different adapter with which to dynamically server-render other pages.

Tools built solely to do static site generation may scale the prerendering process more efficiently during build when rendering a very large number of pages. When working with very large statically generated sites, you can avoid long build times with Incremental Static Regeneration (ISR) if using adapter-vercel. And in contrast to purpose-built SSGs, SvelteKit allows for nicely mixing and matching different rendering types on different pages.

Single-page apps 

*[Content truncated - see full docs]*

---

## Remote functions

**URL**: https://kit.svelte.dev/docs/remote-functions

**Contents**:
  - Getting started
  - Core concepts
  - Build and deploy
  - Advanced
  - Best practices
  - Appendix
  - Reference
- Remote functions

Remote functions are a tool for type-safe communication between client and server. They can be called anywhere in your app, but always run on the server, meaning they can safely access server-only modules containing things like environment variables and database clients.

Combined with Svelte’s experimental support for await, it allows you to load and manipulate data directly inside your components.

This feature is currently experimental, meaning it is likely to contain bugs and is subject to change without notice. You must opt in by adding the kit.experimental.remoteFunctions option in your svelte.config.js and optionally, the compilerOptions.experimental.async option to use await in components:

Remote functions are exported from a .remote.js or .remote.ts file, and come in four flavours: query, form, command and prerender. On the client, the exported functions are transformed to fetch wrappers that invoke their counterparts on the server via a generated HTTP endpoint. Remote files must be placed in your src directory.

The query function allows you to read dynamic data from the server (for static data, consider using prerender instead):

Creates a remote query. When called from the browser, the function will be invoked on the server via a fetch call.

See Remote functions for full documentation.

Creates a remote query. When called from the browser, the function will be invoked on the server via a fetch call.

See Remote functions for full documentation.

Throughout this page, you’ll see imports from fictional modules like $lib/server/database and $lib/server/auth. These are purely for illustrative purposes — you can use whatever database client and auth setup you like.

The db.sql function above is a tagged template function that escapes any interpolated values.

The query returned from getPosts works as a Promise that resolves to posts:

Until the promise resolves — and if it errors — the nearest <svelte:boundary> will be invoked.

While using await is recomme

*[Content truncated - see full docs]*

**Examples**:

```javascript
/** @type {import('@sveltejs/kit').Config} */
const const config: {
    kit: {
        experimental: {
 remoteFunctions: boolean;
        };
    };
    compilerOptions: {
        experimental: {
 async: boolean;
        };
    };
}@type{import('@sveltejs/kit').Config}config = {
	kit: {
    experimental: {
        remoteFunctions: boolean;
    };
}kit: {
		experimental: {
    remoteFunctions: boolean;
}experimental: {
			remoteFunctions: booleanremoteFunctions: true
		}
	},
	compilerOptions: {
  
...
```

```javascript
const config: {
    kit: {
        experimental: {
 remoteFunctions: boolean;
        };
    };
    compilerOptions: {
        experimental: {
 async: boolean;
        };
    };
}
```

```javascript
const config: {
    kit: {
        experimental: {
 remoteFunctions: boolean;
        };
    };
    compilerOptions: {
        experimental: {
 async: boolean;
        };
    };
}
```

---

## Server-only modules

**URL**: https://kit.svelte.dev/docs/server-only-modules

**Contents**:
  - Getting started
  - Core concepts
  - Build and deploy
  - Advanced
  - Best practices
  - Appendix
  - Reference
- Server-only modules

Like a good friend, SvelteKit keeps your secrets. When writing your backend and frontend in the same repository, it can be easy to accidentally import sensitive data into your front-end code (environment variables containing API keys, for example). SvelteKit provides a way to prevent this entirely: server-only modules.

The $env/static/private and $env/dynamic/private modules can only be imported into modules that only run on the server, such as hooks.server.js or +page.server.js.

The $app/server module, which contains a read function for reading assets from the filesystem, can likewise only be imported by code that runs on the server.

You can make your own modules server-only in two ways:

Any time you have public-facing code that imports server-only code (whether directly or indirectly)...

...SvelteKit will error:

Even though the public-facing code — src/routes/+page.svelte — only uses the add export and not the secret atlantisCoordinates export, the secret code could end up in JavaScript that the browser downloads, and so the import chain is considered unsafe.

This feature also works with dynamic imports, even interpolated ones like await import(`./${foo}.js`).

Unit testing frameworks like Vitest do not distinguish between server-only and public-facing code. For this reason, illegal import detection is disabled when running tests, as determined by process.env.TEST === 'true'.

Edit this page on GitHub llms.txt

**Examples**:

```javascript
export const atlantisCoordinates = [/* redacted */];
```

```javascript
export { export atlantisCoordinatesatlantisCoordinates } from '$lib/server/secrets.js';

export const const add: (a: any, b: any) => anyadd = (a, b) => a: anya + b: anyb;
```

```text
export atlantisCoordinates
```

---

## Service workers

**URL**: https://kit.svelte.dev/docs/service-workers

**Contents**:
  - Getting started
  - Core concepts
  - Build and deploy
  - Advanced
  - Best practices
  - Appendix
  - Reference
- Service workers

Service workers act as proxy servers that handle network requests inside your app. This makes it possible to make your app work offline, but even if you don’t need offline support (or can’t realistically implement it because of the type of app you’re building), it’s often worth using service workers to speed up navigation by precaching your built JS and CSS.

In SvelteKit, if you have a src/service-worker.js file (or src/service-worker/index.js) it will be bundled and automatically registered. You can change the location of your service worker if you need to.

You can disable automatic registration if you need to register the service worker with your own logic or use another solution. The default registration looks something like this:

Available only in secure contexts.

Inside the service worker you have access to the $service-worker module, which provides you with the paths to all static assets, build files and prerendered pages. You’re also provided with an app version string, which you can use for creating a unique cache name, and the deployment’s base path. If your Vite config specifies define (used for global variable replacements), this will be applied to service workers as well as your server/client builds.

The following example caches the built app and any files in static eagerly, and caches all other requests as they happen. This would make each page work offline once visited.

An array of URL strings representing the files generated by Vite, suitable for caching with cache.addAll(build). During development, this is an empty array.

An array of URL strings representing the files in your static directory, or whatever directory is specified by config.kit.files.assets. You can customize which files are included from static directory using config.kit.serviceWorker.files

See config.kit.version. It’s useful for generating unique cache names inside your service worker, so that a later deployment of your app can invalidate old caches.

See config.kit.version. I

*[Content truncated - see full docs]*

**Examples**:

```javascript
if ('serviceWorker' in var navigator: NavigatorMDN Reference
navigator) {
	function addEventListener<"load">(type: "load", listener: (this: Window, ev: Event) => any, options?: boolean | AddEventListenerOptions): void (+1 overload)addEventListener('load', function () {
		var navigator: NavigatorMDN Reference
navigator.Navigator.serviceWorker: ServiceWorkerContainerAvailable only in secure contexts.
MDN Reference
serviceWorker.ServiceWorkerContainer.register(scriptURL: string | URL, options?: Reg
...
```

```text
var navigator: Navigator
```

```javascript
function addEventListener<"load">(type: "load", listener: (this: Window, ev: Event) => any, options?: boolean | AddEventListenerOptions): void (+1 overload)
```

---

## Single-page apps

**URL**: https://kit.svelte.dev/docs/single-page-apps

**Contents**:
  - Getting started
  - Core concepts
  - Build and deploy
  - Advanced
  - Best practices
  - Appendix
  - Reference
- Single-page apps

You can turn a SvelteKit app into a fully client-rendered single-page app (SPA) by specifying a fallback page. This page will be served for any URLs that can’t be served by other means such as returning a prerendered page.

SPA mode has a large negative performance impact by forcing multiple network round trips (for the blank HTML document, then for the JavaScript, and then for any data needed for the page) before content can be shown. Unless you are serving the app from a local network (e.g.a mobile app that wraps a locally-served SPA) this will delay startup, especially when considering the latency of mobile devices. It also harms SEO by often causing sites to be downranked for performance (SPAs are much more likely to fail Core Web Vitals), excluding search engines that don’t render JS, and causing your site to receive less frequent updates from those that do. And finally, it makes your app inaccessible to users if JavaScript fails or is disabled (which happens more often than you probably think).

You can avoid these drawbacks by prerendering as many pages as possible when using SPA mode (especially your homepage). If you can prerender all pages, you can simply use static site generation rather than a SPA. Otherwise, you should strongly consider using an adapter which supports server side rendering. SvelteKit has officially supported adapters for various providers with generous free tiers.

First, disable SSR for the pages you don’t want to prerender. These pages will be served via the fallback page. E.g. to serve all pages via the fallback by default, you can update the root layout as shown below. You should opt back into prerendering individual pages and directories where possible.

If you don’t have any server-side logic (i.e. +page.server.js, +layout.server.js or +server.js files) you can use adapter-static to create your SPA. Install adapter-static with npm i -D @sveltejs/adapter-static and add it to your svelte.config.js with the fallback option:

The fall

*[Content truncated - see full docs]*

**Examples**:

```javascript
export const const ssr: falsessr = false;
```

```javascript
const ssr: false
```

```python
import import adapteradapter from '@sveltejs/adapter-static';

/** @type {import('@sveltejs/kit').Config} */
const const config: {
    kit: {
        adapter: any;
    };
}@type{import('@sveltejs/kit').Config}config = {
	kit: {
    adapter: any;
}kit: {
		adapter: anyadapter: import adapteradapter({
			fallback: stringfallback: '200.html' // may differ from host to host
		})
	}
};

export default const config: {
    kit: {
        adapter: any;
    };
}@type{import('@sveltejs/kit').Config}config
...
```

---

## Static site generation

**URL**: https://kit.svelte.dev/docs/adapter-static

**Contents**:
  - Getting started
  - Core concepts
  - Build and deploy
  - Advanced
  - Best practices
  - Appendix
  - Reference
- Static site generation

To use SvelteKit as a static site generator (SSG), use adapter-static.

This will prerender your entire site as a collection of static files. If you’d like to prerender only some pages and dynamically server-render others, you will need to use a different adapter together with the prerender option.

Install with npm i -D @sveltejs/adapter-static, then add the adapter to your svelte.config.js:

...and add the prerender option to your root layout:

You must ensure SvelteKit’s trailingSlash option is set appropriately for your environment. If your host does not render /a.html upon receiving a request for /a then you will need to set trailingSlash: 'always' in your root layout to create /a/index.html instead.

Some platforms have zero-config support (more to come in future):

On these platforms, you should omit the adapter options so that adapter-static can provide the optimal configuration:

The directory to write prerendered pages to. It defaults to build.

The directory to write static assets (the contents of static, plus client-side JS and CSS generated by SvelteKit) to. Ordinarily this should be the same as pages, and it will default to whatever the value of pages is, but in rare circumstances you might need to output pages and assets to separate locations.

To create a single page app (SPA) you must specify the name of the fallback page to be generated by SvelteKit, which is used as the entry point for URLs that have not been prerendered. This is commonly 200.html, but can vary depending on your deployment platform. You should avoid index.html where possible to avoid conflicting with a prerendered homepage.

This option has large negative performance and SEO impacts. It is only recommended in certain circumstances such as wrapping the site in a mobile app. See the single page apps documentation for more details and alternatives.

If true, precompresses files with brotli and gzip. This will generate .br and .gz files.

By default, adapter-static checks that either 

*[Content truncated - see full docs]*

**Examples**:

```python
import import adapteradapter from '@sveltejs/adapter-static';

/** @type {import('@sveltejs/kit').Config} */
const const config: {
    kit: {
        adapter: any;
    };
}@type{import('@sveltejs/kit').Config}config = {
	kit: {
    adapter: any;
}kit: {
		adapter: anyadapter: import adapteradapter({
			// default options are shown. On some platforms
			// these options are set automatically — see below
			pages: stringpages: 'build',
			assets: stringassets: 'build',
			fallback: undefinedfallba
...
```

```text
import adapter
```

```javascript
const config: {
    kit: {
        adapter: any;
    };
}
```

---

## Vercel

**URL**: https://kit.svelte.dev/docs/adapter-vercel

**Contents**:
  - Getting started
  - Core concepts
  - Build and deploy
  - Advanced
  - Best practices
  - Appendix
  - Reference
- Vercel

To deploy to Vercel, use adapter-vercel.

This adapter will be installed by default when you use adapter-auto, but adding it to your project allows you to specify Vercel-specific options.

Install with npm i -D @sveltejs/adapter-vercel, then add the adapter to your svelte.config.js:

To control how your routes are deployed to Vercel as functions, you can specify deployment configuration, either through the option shown above or with export const config inside +server.js, +page(.server).js and +layout(.server).js files.

For example you could deploy one specific route as an individual serverless function, separate from the rest of your app:

The following options apply to all functions:

This option is deprecated and will be removed in a future version, at which point all your functions will use whichever Node version is specified in the project configuration on Vercel

Additionally, the following option applies to edge functions:

And the following option apply to serverless functions:

Configuration set in a layout applies to all the routes beneath that layout, unless overridden at a more granular level.

If your functions need to access data in a specific region, it’s recommended that they be deployed in the same region (or close to it) for optimal performance.

You may set the images config to control how Vercel builds your images. See the image configuration reference for full details. As an example, you may set:

https://vercel.com/docs/build-output-api/v3/configuration#images

Vercel supports Incremental Static Regeneration (ISR), which provides the performance and cost advantages of prerendered content with the flexibility of dynamically rendered content.

Use ISR only on routes where every visitor should see the same content (much like when you prerender). If there’s anything user-specific happening (like session cookies), they should happen on the client via JavaScript only to not leak sensitive information across visits

To add ISR to a route, include the 

*[Content truncated - see full docs]*

**Examples**:

```python
import function adapter(config?: Config): Adapteradapter from '@sveltejs/adapter-vercel';

/** @type {import('@sveltejs/kit').Config} */
const const config: {
    kit: {
        adapter: Adapter;
    };
}@type{import('@sveltejs/kit').Config}config = {
	kit: {
    adapter: Adapter;
}kit: {
		adapter: Adapteradapter: function adapter(config?: Config): Adapteradapter({
			// see below for options that can be set here
		})
	}
};

export default const config: {
    kit: {
        adapter: Adapter;
  
...
```

```javascript
function adapter(config?: Config): Adapter
```

```javascript
const config: {
    kit: {
        adapter: Adapter;
    };
}
```

---

## Zero-config deployments

**URL**: https://kit.svelte.dev/docs/adapter-auto

**Contents**:
  - Getting started
  - Core concepts
  - Build and deploy
  - Advanced
  - Best practices
  - Appendix
  - Reference
- Zero-config deployments

When you create a new SvelteKit project with npx sv create, it installs adapter-auto by default. This adapter automatically installs and uses the correct adapter for supported environments when you deploy:

It’s recommended to install the appropriate adapter to your devDependencies once you’ve settled on a target environment, since this will add the adapter to your lockfile and slightly improve install times on CI.

To add configuration options, such as { edge: true } in adapter-vercel and adapter-netlify, you must install the underlying adapter — adapter-auto does not take any options.

You can add zero-config support for additional adapters by editing adapters.js and opening a pull request.

Edit this page on GitHub llms.txt

---

## $app/environment

**URL**: https://kit.svelte.dev/docs/$app-environment

**Contents**:
  - Getting started
  - Core concepts
  - Build and deploy
  - Advanced
  - Best practices
  - Appendix
  - Reference
- $app/environment

true if the app is running in the browser.

SvelteKit analyses your app during the build step by running it. During this process, building is true. This also applies during prerendering.

Whether the dev server is running. This is not guaranteed to correspond to NODE_ENV or MODE.

The value of config.kit.version.name.

true if the app is running in the browser.

SvelteKit analyses your app during the build step by running it. During this process, building is true. This also applies during prerendering.

Whether the dev server is running. This is not guaranteed to correspond to NODE_ENV or MODE.

The value of config.kit.version.name.

Edit this page on GitHub llms.txt

**Examples**:

```python
import { const browser: booleantrue if the app is running in the browser.
browser, const building: booleanSvelteKit analyses your app during the build step by running it. During this process, building is true. This also applies during prerendering.
building, const dev: booleanWhether the dev server is running. This is not guaranteed to correspond to NODE_ENV or MODE.
dev, const version: stringThe value of config.kit.version.name.
version } from '$app/environment';
```

```javascript
const browser: boolean
```

```javascript
const building: boolean
```

---

## $app/navigation

**URL**: https://kit.svelte.dev/docs/$app-navigation

**Contents**:
  - Getting started
  - Core concepts
  - Build and deploy
  - Advanced
  - Best practices
  - Appendix
  - Reference
- $app/navigation

A lifecycle function that runs the supplied callback when the current component mounts, and also whenever we navigate to a URL.

afterNavigate must be called during a component initialization. It remains active as long as the component is mounted.

A navigation interceptor that triggers before we navigate to a URL, whether by clicking a link, calling goto(...), or using the browser back/forward controls.

Calling cancel() will prevent the navigation from completing. If navigation.type === 'leave' — meaning the user is navigating away from the app (or closing the tab) — calling cancel will trigger the native browser unload confirmation dialog. In this case, the navigation may or may not be cancelled depending on the user’s response.

When a navigation isn’t to a SvelteKit-owned route (and therefore controlled by SvelteKit’s client-side router), navigation.to.route.id will be null.

If the navigation will (if not cancelled) cause the document to unload — in other words 'leave' navigations and 'link' navigations where navigation.to.route === null — navigation.willUnload is true.

beforeNavigate must be called during a component initialization. It remains active as long as the component is mounted.

If called when the page is being updated following a navigation (in onMount or afterNavigate or an action, for example), this disables SvelteKit’s built-in scroll handling. This is generally discouraged, since it breaks user expectations.

Allows you to navigate programmatically to a given route, with options such as keeping the current element focused. Returns a Promise that resolves when SvelteKit navigates (or fails to navigate, in which case the promise rejects) to the specified url.

For external URLs, use window.location = url instead of calling goto(url).

Causes any load functions belonging to the currently active page to re-run if they depend on the url in question, via fetch or depends. Returns a Promise that resolves when the page is subsequently updated.

If the 

*[Content truncated - see full docs]*

**Examples**:

```python
import {
	function afterNavigate(callback: (navigation: import("@sveltejs/kit").AfterNavigate) => void): voidA lifecycle function that runs the supplied callback when the current component mounts, and also whenever we navigate to a URL.
afterNavigate must be called during a component initialization. It remains active as long as the component is mounted.
afterNavigate,
	function beforeNavigate(callback: (navigation: import("@sveltejs/kit").BeforeNavigate) => void): voidA navigation interceptor th
...
```

```javascript
function afterNavigate(callback: (navigation: import("@sveltejs/kit").AfterNavigate) => void): void
```

```text
afterNavigate
```

---

## $app/server

**URL**: https://kit.svelte.dev/docs/$app-server

**Contents**:
  - Getting started
  - Core concepts
  - Build and deploy
  - Advanced
  - Best practices
  - Appendix
  - Reference
- $app/server

Creates a remote command. When called from the browser, the function will be invoked on the server via a fetch call.

See Remote functions for full documentation.

Creates a form object that can be spread onto a &#x3C;form> element.

See Remote functions for full documentation.

Returns the current RequestEvent. Can be used inside server hooks, server load functions, actions, and endpoints (and functions called by them).

In environments without AsyncLocalStorage, this must be called synchronously (i.e. not after an await).

Creates a remote prerender function. When called from the browser, the function will be invoked on the server via a fetch call.

See Remote functions for full documentation.

Creates a remote query. When called from the browser, the function will be invoked on the server via a fetch call.

See Remote functions for full documentation.

Read the contents of an imported asset from the filesystem

Creates a remote command. When called from the browser, the function will be invoked on the server via a fetch call.

See Remote functions for full documentation.

Creates a form object that can be spread onto a <form> element.

See Remote functions for full documentation.

Available since 2.20.0

Returns the current RequestEvent. Can be used inside server hooks, server load functions, actions, and endpoints (and functions called by them).

In environments without AsyncLocalStorage, this must be called synchronously (i.e. not after an await).

Creates a remote prerender function. When called from the browser, the function will be invoked on the server via a fetch call.

See Remote functions for full documentation.

Creates a remote query. When called from the browser, the function will be invoked on the server via a fetch call.

See Remote functions for full documentation.

Available since 2.4.0

Read the contents of an imported asset from the filesystem

Read the contents of an imported asset from the filesystem

Read the contents of an imported asset fro

*[Content truncated - see full docs]*

**Examples**:

```python
import {
	function command<Output>(fn: () => Output): RemoteCommand<void, Output> (+2 overloads)Creates a remote command. When called from the browser, the function will be invoked on the server via a fetch call.
See Remote functions for full documentation.
@since2.27command,
	function form<Output>(fn: () => MaybePromise<Output>): RemoteForm<void, Output> (+2 overloads)Creates a form object that can be spread onto a &#x3C;form> element.
See Remote functions for full documentation.
@since2.27form
...
```

```javascript
function command<Output>(fn: () => Output): RemoteCommand<void, Output> (+2 overloads)
```

```javascript
function form<Output>(fn: () => MaybePromise<Output>): RemoteForm<void, Output> (+2 overloads)
```

---

## $env/dynamic/private

**URL**: https://kit.svelte.dev/docs/$env-dynamic-private

**Contents**:
  - Getting started
  - Core concepts
  - Build and deploy
  - Advanced
  - Best practices
  - Appendix
  - Reference
- $env/dynamic/private

This module provides access to runtime environment variables, as defined by the platform you’re running on. For example if you’re using adapter-node (or running vite preview), this is equivalent to process.env. This module only includes variables that do not begin with config.kit.env.publicPrefix and do start with config.kit.env.privatePrefix (if configured).

This module cannot be imported into client-side code.

The console module provides a simple debugging console that is similar to the JavaScript console mechanism provided by web browsers.

The module exports two specific components:

Warning: The global console object’s methods are neither consistently synchronous like the browser APIs they resemble, nor are they consistently asynchronous like all other Node.js streams. See the note on process I/O for more information.

Example using the global console:

Example using the Console class:

Prints to stdout with newline. Multiple arguments can be passed, with the first used as the primary message and all additional used as substitution values similar to printf(3) (the arguments are all passed to util.format()).

See util.format() for more information.

In dev, $env/dynamic always includes environment variables from .env. In prod, this behavior will depend on your adapter.

Edit this page on GitHub llms.txt

**Examples**:

```python
import { import envenv } from '$env/dynamic/private';
var console: ConsoleThe console module provides a simple debugging console that is similar to the
JavaScript console mechanism provided by web browsers.
The module exports two specific components:

A Console class with methods such as console.log(), console.error() and console.warn() that can be used to write to any Node.js stream.
A global console instance configured to write to process.stdout and
process.stderr. The global console can be us
...
```

```text
var console: Console
```

```text
console.log()
```

---

## $env/static/private

**URL**: https://kit.svelte.dev/docs/$env-static-private

**Contents**:
  - Getting started
  - Core concepts
  - Build and deploy
  - Advanced
  - Best practices
  - Appendix
  - Reference
- $env/static/private

Environment variables loaded by Vite from .env files and process.env. Like $env/dynamic/private, this module cannot be imported into client-side code. This module only includes variables that do not begin with config.kit.env.publicPrefix and do start with config.kit.env.privatePrefix (if configured).

Unlike $env/dynamic/private, the values exported from this module are statically injected into your bundle at build time, enabling optimisations like dead code elimination.

Note that all environment variables referenced in your code should be declared (for example in an .env file), even if they don’t have a value until the app is deployed:

You can override .env values from the command line like so:

Edit this page on GitHub llms.txt

**Examples**:

```python
import { import API_KEYAPI_KEY } from '$env/static/private';
```

```text
import API_KEY
```

```text
MY_FEATURE_FLAG=""
```

---

## $lib

**URL**: https://kit.svelte.dev/docs/$lib

**Contents**:
  - Getting started
  - Core concepts
  - Build and deploy
  - Advanced
  - Best practices
  - Appendix
  - Reference
- $lib

SvelteKit automatically makes files under src/lib available using the $lib import alias. You can change which directory this alias points to in your config file.

Edit this page on GitHub llms.txt

**Examples**:

```text
A reusable component
```

```python
<script>
	import Component from '$lib/Component.svelte';
</script>

<Component />
```

```python
<script lang="ts">
	import Component from '$lib/Component.svelte';
</script>

<Component />
```

---

## $service-worker

**URL**: https://kit.svelte.dev/docs/$service-worker

**Contents**:
  - Getting started
  - Core concepts
  - Build and deploy
  - Advanced
  - Best practices
  - Appendix
  - Reference
- $service-worker

The base path of the deployment. Typically this is equivalent to config.kit.paths.base, but it is calculated from location.pathname meaning that it will continue to work correctly if the site is deployed to a subdirectory. Note that there is a base but no assets, since service workers cannot be used if config.kit.paths.assets is specified.

An array of URL strings representing the files generated by Vite, suitable for caching with cache.addAll(build). During development, this is an empty array.

An array of URL strings representing the files in your static directory, or whatever directory is specified by config.kit.files.assets. You can customize which files are included from static directory using config.kit.serviceWorker.files

An array of pathnames corresponding to prerendered pages and endpoints. During development, this is an empty array.

See config.kit.version. It’s useful for generating unique cache names inside your service worker, so that a later deployment of your app can invalidate old caches.

This module is only available to service workers.

The base path of the deployment. Typically this is equivalent to config.kit.paths.base, but it is calculated from location.pathname meaning that it will continue to work correctly if the site is deployed to a subdirectory. Note that there is a base but no assets, since service workers cannot be used if config.kit.paths.assets is specified.

An array of URL strings representing the files generated by Vite, suitable for caching with cache.addAll(build). During development, this is an empty array.

An array of URL strings representing the files in your static directory, or whatever directory is specified by config.kit.files.assets. You can customize which files are included from static directory using config.kit.serviceWorker.files

An array of pathnames corresponding to prerendered pages and endpoints. During development, this is an empty array.

See config.kit.version. It’s useful for generating unique cache names 

*[Content truncated - see full docs]*

**Examples**:

```python
import { const base: stringThe base path of the deployment. Typically this is equivalent to config.kit.paths.base, but it is calculated from location.pathname meaning that it will continue to work correctly if the site is deployed to a subdirectory.
Note that there is a base but no assets, since service workers cannot be used if config.kit.paths.assets is specified.
base, const build: string[]An array of URL strings representing the files generated by Vite, suitable for caching with cache.addAll
...
```

```javascript
const base: string
```

```text
config.kit.paths.base
```

---

## @sveltejs/kit/hooks

**URL**: https://kit.svelte.dev/docs/@sveltejs-kit-hooks

**Contents**:
  - Getting started
  - Core concepts
  - Build and deploy
  - Advanced
  - Best practices
  - Appendix
  - Reference
- @sveltejs/kit/hooks

A helper function for sequencing multiple handle calls in a middleware-like manner. The behavior for the handle options is as follows:

The example above would print:

A helper function for sequencing multiple handle calls in a middleware-like manner. The behavior for the handle options is as follows:

A helper function for sequencing multiple handle calls in a middleware-like manner. The behavior for the handle options is as follows:

The example above would print:

The console module provides a simple debugging console that is similar to the JavaScript console mechanism provided by web browsers.

The module exports two specific components:

Warning: The global console object’s methods are neither consistently synchronous like the browser APIs they resemble, nor are they consistently asynchronous like all other Node.js streams. See the note on process I/O for more information.

Example using the global console:

Example using the Console class:

Prints to stdout with newline. Multiple arguments can be passed, with the first used as the primary message and all additional used as substitution values similar to printf(3) (the arguments are all passed to util.format()).

See util.format() for more information.

The console module provides a simple debugging console that is similar to the JavaScript console mechanism provided by web browsers.

The module exports two specific components:

Warning: The global console object’s methods are neither consistently synchronous like the browser APIs they resemble, nor are they consistently asynchronous like all other Node.js streams. See the note on process I/O for more information.

Example using the global console:

Example using the Console class:

Prints to stdout with newline. Multiple arguments can be passed, with the first used as the primary message and all additional used as substitution values similar to printf(3) (the arguments are all passed to util.format()).

See util.format() for more information.

The console modu

*[Content truncated - see full docs]*

**Examples**:

```python
import { function sequence(...handlers: Handle[]): HandleA helper function for sequencing multiple handle calls in a middleware-like manner.
The behavior for the handle options is as follows:

transformPageChunk is applied in reverse order and merged
preload is applied in forward order, the first option “wins” and no preload options after it are called
filterSerializedResponseHeaders behaves the same as preload

src/hooks.serverimport { sequence } from '@sveltejs/kit/hooks';

/// type: import('@
...
```

```javascript
function sequence(...handlers: Handle[]): Handle
```

```text
transformPageChunk
```

---

## @sveltejs/kit/vite

**URL**: https://kit.svelte.dev/docs/@sveltejs-kit-vite

**Contents**:
  - Getting started
  - Core concepts
  - Build and deploy
  - Advanced
  - Best practices
  - Appendix
  - Reference
- @sveltejs/kit/vite

Returns the SvelteKit Vite plugins.

Returns the SvelteKit Vite plugins.

Edit this page on GitHub llms.txt

**Examples**:

```python
import { function sveltekit(): Promise<Plugin$1<any>[]>Returns the SvelteKit Vite plugins.
sveltekit } from '@sveltejs/kit/vite';
```

```javascript
function sveltekit(): Promise<Plugin$1<any>[]>
```

```javascript
function sveltekit(): Promise<import('vite').Plugin[]>;
```

---
